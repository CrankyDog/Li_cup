-- -------------------------------------------------------------
-- 
-- File Name: D:\qq\li\hdl_coder\lms_hdl_coder\codegen\mlhdlc_lms_fcn\hdlsrc\mlhdlc_lms_fcn_fixpt.vhd
-- Created: 2022-07-17 20:03:53
-- 
-- Generated by MATLAB 9.12, MATLAB Coder 5.4 and HDL Coder 3.20
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Design base rate: 1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: mlhdlc_lms_fcn_fixpt
-- Source Path: mlhdlc_lms_fcn_fixpt
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.mlhdlc_lms_fcn_fixpt_pkg.ALL;

ENTITY mlhdlc_lms_fcn_fixpt IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        input                             :   IN    signed(15 DOWNTO 0);  -- sfix16
        desired                           :   IN    signed(15 DOWNTO 0);  -- sfix16
        filtered_signal                   :   OUT   signed(15 DOWNTO 0);  -- sfix16
        y                                 :   OUT   signed(15 DOWNTO 0)  -- sfix16
        );
END mlhdlc_lms_fcn_fixpt;


ARCHITECTURE rtl OF mlhdlc_lms_fcn_fixpt IS

  -- Signals
  SIGNAL tmp                              : vector_of_signed15(0 TO 39);  -- sfix15 [40]
  SIGNAL u_d                              : vector_of_signed15(0 TO 39);  -- sfix15 [40]
  SIGNAL td                               : signed(14 DOWNTO 0);  -- sfix15
  SIGNAL vt                               : vector_of_signed16(0 TO 1);  -- sfix16_En2 [2]
  SIGNAL vt_1                             : vector_of_signed16(0 TO 2);  -- sfix16_En2 [3]
  SIGNAL tmp_1                            : signed(15 DOWNTO 0);  -- sfix16_En2
  SIGNAL vt_2                             : vector_of_signed16(0 TO 4);  -- sfix16_En2 [5]
  SIGNAL vt_3                             : vector_of_signed16(0 TO 2);  -- sfix16_En2 [3]
  SIGNAL p3vt_cast                        : vector_of_signed64(0 TO 2);  -- sfix64 [3]
  SIGNAL vt_4                             : vector_of_signed16(0 TO 9);  -- sfix16_En1 [10]
  SIGNAL vt_5                             : vector_of_signed16(0 TO 4);  -- sfix16_En2 [5]
  SIGNAL p6vt_cast                        : vector_of_signed64(0 TO 4);  -- sfix64 [5]
  SIGNAL vt_6                             : vector_of_signed16(0 TO 19);  -- sfix16_En1 [20]
  SIGNAL vt_7                             : vector_of_signed16(0 TO 9);  -- sfix16_En1 [10]
  SIGNAL p9vt_cast                        : vector_of_signed64(0 TO 9);  -- sfix64 [10]
  SIGNAL weight_applied                   : vector_of_signed16(0 TO 39);  -- sfix16_En1 [40]
  SIGNAL vt_8                             : vector_of_signed16(0 TO 19);  -- sfix16_En1 [20]
  SIGNAL p12vt_cast                       : vector_of_signed64(0 TO 19);  -- sfix64 [20]
  SIGNAL filtered_signal_1                : signed(15 DOWNTO 0);  -- sfix16
  SIGNAL tf                               : signed(15 DOWNTO 0);  -- sfix16_En2
  SIGNAL esig                             : signed(15 DOWNTO 0);  -- sfix16_En2
  SIGNAL p28esig_sub_cast                 : signed(17 DOWNTO 0);  -- sfix18_En2
  SIGNAL p28esig_sub_cast_1               : signed(17 DOWNTO 0);  -- sfix18_En2
  SIGNAL p28esig_sub_temp                 : signed(17 DOWNTO 0);  -- sfix18_En2
  SIGNAL step_sig                         : signed(15 DOWNTO 0);  -- sfix16_En32
  SIGNAL p30step_sig_mul_temp             : signed(32 DOWNTO 0);  -- sfix33_En47
  SIGNAL p30step_sig_cast                 : signed(31 DOWNTO 0);  -- sfix32_En47
  SIGNAL correction_factor                : vector_of_signed16(0 TO 39);  -- sfix16_En19 [40]
  SIGNAL p31correction_factor_mul_temp    : vector_of_signed31(0 TO 39);  -- sfix31_En32 [40]
  SIGNAL filter_coeff                     : vector_of_signed16(0 TO 39);  -- sfix16_En14 [40]
  SIGNAL updated_weight                   : vector_of_signed16(0 TO 39);  -- sfix16_En14 [40]
  SIGNAL p33updated_weight_add_cast       : vector_of_signed22(0 TO 39);  -- sfix22_En19 [40]
  SIGNAL p33updated_weight_add_cast_1     : vector_of_signed22(0 TO 39);  -- sfix22_En19 [40]
  SIGNAL p33updated_weight_add_temp       : vector_of_signed22(0 TO 39);  -- sfix22_En19 [40]
  SIGNAL p13weight_applied_mul_temp       : vector_of_signed31(0 TO 39);  -- sfix31_En14 [40]
  SIGNAL p18vt_cast                       : vector_of_signed64(0 TO 1);  -- sfix64 [2]
  SIGNAL vt_13                            : vector_of_signed16(0 TO 1);  -- sfix16_En2 [2]
  SIGNAL vt_14                            : signed(15 DOWNTO 0);  -- sfix16_En2
  SIGNAL vt_15                            : signed(15 DOWNTO 0);  -- sfix16_En2

BEGIN
  -- update filter coefficients register
  u_d_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      u_d <= (OTHERS => to_signed(16#0000#, 15));
    ELSIF clk'EVENT AND clk = '1' THEN
      u_d <= tmp;
    END IF;
  END PROCESS u_d_reg_process;


  -- HDL code generation from MATLAB function: mlhdlc_lms_fcn_fixpt
  -- 
  -- add the following compilation directive or pragma to the function code
  -- 
  -- NOTE: To instruct MATLAB Coder to compile an external function, 
  -- 
  -- form. The output includes current input
  -- 
  -- of sample periods, and outputs all the delayed versions in a vector
  -- 
  -- The Tapped Delay function delays its input by the specified number 
  -- 
  -- 40-step tapped delay
  -- 
  -- Variable Filter: Call 'tapped_delay_fcn' function on path to create 
  -- 
  -- register filter coefficients
  -- 
  -- are updated(adapted) in real-time based on 'input' and 'err_sig'.
  -- 
  -- cancel the noise in Pilot's Mic. The coefficients/weights of the filter 
  -- 
  -- from Pilot's Mic by filtering the Exterior Mic's signal and using it to 
  -- 
  -- The LMS filter is trying to retrieve the original music signal('err_sig') 
  -- 
  -- 
  -- 
  --           It represents the estimated music signal (output of this block)
  -- 
  -- 'err_sig': The difference between the 'desired' and the filtered 'input'
  -- 
  --            original music signal and the noise signal
  -- 
  -- 'desired': The signal from Pilot's Mic which includes 
  -- 
  -- 'input'  : The signal from Exterior Mic which records the ambient noise.
  -- 
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- 
  -- (3) Use of system objects in the testbench to stream test vectors into the design
  -- 
  -- (2) Function inlining vs instantiation knobs available in the coder
  -- 
  -- (1) Use of function calls
  -- 
  -- Key Design pattern covered in this example: 
  -- 
  -- (LMS) filter implemented in MATLAB
  -- 
  -- MATLAB Design: Adaptive Noise Canceler algorithm using Least Mean Square 
  -- 
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- 
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  -- 
  --                                                                          %
  -- 
  --          Generated by MATLAB 9.12 and Fixed-Point Designer 7.4           %
  -- 
  --                                                                          %
  -- 
  -- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  tmp(0 TO 38) <= u_d(1 TO 39);
  tmp(39) <= input(14 DOWNTO 0);

  -- Output estimated Original Signal
  td <= desired(14 DOWNTO 0);

  tmp_1 <= vt(0) + vt_1(1);


  vt_3_gen: FOR t_0 IN 0 TO 2 GENERATE
    p3vt_cast(t_0) <= resize(to_signed(t_0, 32) & '0', 64);
    vt_3(t_0) <= vt_2(to_integer(resize(p3vt_cast(t_0), 31)));
  END GENERATE vt_3_gen;



  vt_5_gen: FOR t_01 IN 0 TO 4 GENERATE
    p6vt_cast(t_01) <= resize(to_signed(t_01, 32) & '0', 64);
    vt_5(t_01) <= vt_4(to_integer(resize(p6vt_cast(t_01), 31)))(14 DOWNTO 0) & '0';
  END GENERATE vt_5_gen;



  vt_7_gen: FOR t_02 IN 0 TO 9 GENERATE
    p9vt_cast(t_02) <= resize(to_signed(t_02, 32) & '0', 64);
    vt_7(t_02) <= vt_6(to_integer(resize(p9vt_cast(t_02), 31)));
  END GENERATE vt_7_gen;


  -- This implementation is hardwired for a 40tap filter.
  -- 
  -- add the following compilation directive or pragma to the function code
  -- 
  -- NOTE: To instruct MATLAB Coder to compile an external function, 
  -- 
  --  recursion but it is not currently supported by MATLAB Coder
  -- 
  --  The ideal way to code this generically for any length of 'u' is to use 
  -- 
  --  a tree shape to enable hardware optimizations.
  -- 
  --  This implementation shows how to explicitly implement the vector sum in 
  -- 
  --  delay of log2(N) instead of a delay of N delay
  -- 
  --  A tree is more efficient as it results in
  -- 
  --  HDL generation and results in a longer critical path. 
  -- 
  --  The loop based implementation of 'sum' function is not ideal for 
  -- 
  --  y = sum(u);
  -- 
  -- Implement the 'sum' function without a for-loop
  -- 
  -- Call treesum function on matlab path to sum up the results

  vt_8_gen: FOR t_03 IN 0 TO 19 GENERATE
    p12vt_cast(t_03) <= resize(to_signed(t_03, 32) & '0', 64);
    vt_8(t_03) <= weight_applied(to_integer(resize(p12vt_cast(t_03), 31)));
  END GENERATE vt_8_gen;


  tf <= filtered_signal_1(13 DOWNTO 0) & '0' & '0';

  p28esig_sub_cast <= resize(td & '0' & '0', 18);
  p28esig_sub_cast_1 <= resize(tf, 18);
  p28esig_sub_temp <= p28esig_sub_cast - p28esig_sub_cast_1;
  esig <= p28esig_sub_temp(15 DOWNTO 0);

  -- add the following compilation directive or pragma to the function code
  -- 
  -- NOTE: To instruct MATLAB Coder to compile an external function, 
  -- 
  --   Copyright 2007-2015 The MathWorks, Inc.
  -- 
  -- This function updates the adaptive filter weights based on LMS algorithm
  -- 
  -- calculate the new weights
  -- 
  -- Update Weights: Call 'update_weight_fcn' function on MATLAB path to 
  p30step_sig_mul_temp <= to_signed(16#08970#, 17) * esig;
  p30step_sig_cast <= p30step_sig_mul_temp(31 DOWNTO 0);
  step_sig <= p30step_sig_cast(30 DOWNTO 15);


  correction_factor_gen: FOR t_04 IN 0 TO 39 GENERATE
    p31correction_factor_mul_temp(t_04) <= tmp(t_04) * step_sig;
    correction_factor(t_04) <= p31correction_factor_mul_temp(t_04)(28 DOWNTO 13);
  END GENERATE correction_factor_gen;



  updated_weight_gen: FOR t_05 IN 0 TO 39 GENERATE
    p33updated_weight_add_cast(t_05) <= resize(correction_factor(t_05), 22);
    p33updated_weight_add_cast_1(t_05) <= resize(filter_coeff(t_05) & '0' & '0' & '0' & '0' & '0', 22);
    p33updated_weight_add_temp(t_05) <= p33updated_weight_add_cast(t_05) + p33updated_weight_add_cast_1(t_05);
    updated_weight(t_05) <= p33updated_weight_add_temp(t_05)(20 DOWNTO 5);
  END GENERATE updated_weight_gen;


  filter_coeff_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      filter_coeff <= (OTHERS => to_signed(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      filter_coeff <= updated_weight;
    END IF;
  END PROCESS filter_coeff_reg_process;


  -- Apply filter coefficients 

  weight_applied_gen: FOR t_06 IN 0 TO 39 GENERATE
    p13weight_applied_mul_temp(t_06) <= tmp(t_06) * filter_coeff(t_06);
    weight_applied(t_06) <= p13weight_applied_mul_temp(t_06)(28 DOWNTO 13);
  END GENERATE weight_applied_gen;


  p11_output : PROCESS (vt_8, weight_applied)
    VARIABLE vt9 : vector_of_signed16(0 TO 19);
    VARIABLE sub_cast : vector_of_signed34(0 TO 19);
    VARIABLE sub_cast_0 : vector_of_unsigned6(0 TO 19);
    VARIABLE sub_cast_1 : vector_of_signed32(0 TO 19);
  BEGIN
    vt9 := vt_8;

    FOR i IN 0 TO 19 LOOP
      sub_cast(i) := resize(to_signed(1 + i, 32) * to_signed(16#2#, 3), 34);
      sub_cast_0(i) := unsigned(sub_cast(i)(5 DOWNTO 0));
      sub_cast_1(i) := signed(resize(sub_cast_0(i), 32));
      vt9(i) := vt9(i) + weight_applied(to_integer(sub_cast_1(i) - 1));
    END LOOP;

    vt_6 <= vt9;
  END PROCESS p11_output;


  p8_output : PROCESS (vt_6, vt_7)
    VARIABLE vt10 : vector_of_signed16(0 TO 9);
    VARIABLE sub_cast1 : vector_of_signed34(0 TO 9);
    VARIABLE sub_cast_01 : vector_of_unsigned5(0 TO 9);
    VARIABLE sub_cast_11 : vector_of_signed32(0 TO 9);
  BEGIN
    vt10 := vt_7;

    FOR i1 IN 0 TO 9 LOOP
      sub_cast1(i1) := resize(to_signed(1 + i1, 32) * to_signed(16#2#, 3), 34);
      sub_cast_01(i1) := unsigned(sub_cast1(i1)(4 DOWNTO 0));
      sub_cast_11(i1) := signed(resize(sub_cast_01(i1), 32));
      vt10(i1) := vt10(i1) + vt_6(to_integer(sub_cast_11(i1) - 1));
    END LOOP;

    vt_4 <= vt10;
  END PROCESS p8_output;


  p5_output : PROCESS (vt_4, vt_5)
    VARIABLE vt11 : vector_of_signed16(0 TO 4);
    VARIABLE add_cast : vector_of_signed18(0 TO 4);
    VARIABLE sub_cast2 : vector_of_signed34(0 TO 4);
    VARIABLE sub_cast_02 : vector_of_unsigned4(0 TO 4);
    VARIABLE sub_cast_12 : vector_of_signed32(0 TO 4);
    VARIABLE add_cast_0 : vector_of_signed18(0 TO 4);
    VARIABLE add_temp : vector_of_signed18(0 TO 4);
  BEGIN
    vt11 := vt_5;

    FOR i2 IN 0 TO 4 LOOP
      add_cast(i2) := resize(vt11(i2), 18);
      sub_cast2(i2) := resize(to_signed(1 + i2, 32) * to_signed(16#2#, 3), 34);
      sub_cast_02(i2) := unsigned(sub_cast2(i2)(3 DOWNTO 0));
      sub_cast_12(i2) := signed(resize(sub_cast_02(i2), 32));
      add_cast_0(i2) := resize(vt_4(to_integer(sub_cast_12(i2) - 1)) & '0', 18);
      add_temp(i2) := add_cast(i2) + add_cast_0(i2);
      vt11(i2) := add_temp(i2)(15 DOWNTO 0);
    END LOOP;

    vt_2 <= vt11;
  END PROCESS p5_output;


  p2_output : PROCESS (vt_2, vt_3)
    VARIABLE vt12 : vector_of_signed16(0 TO 2);
    VARIABLE sub_cast3 : vector_of_signed34(0 TO 1);
    VARIABLE sub_cast_03 : vector_of_unsigned3(0 TO 1);
    VARIABLE sub_cast_13 : vector_of_signed32(0 TO 1);
  BEGIN
    vt12 := vt_3;

    FOR i3 IN 0 TO 1 LOOP
      sub_cast3(i3) := resize(to_signed(1 + i3, 32) * to_signed(16#2#, 3), 34);
      sub_cast_03(i3) := unsigned(sub_cast3(i3)(2 DOWNTO 0));
      sub_cast_13(i3) := signed(resize(sub_cast_03(i3), 32));
      vt12(i3) := vt12(i3) + vt_2(to_integer(sub_cast_13(i3) - 1));
    END LOOP;

    vt_1 <= vt12;
  END PROCESS p2_output;



  vt_gen: FOR t_07 IN 0 TO 1 GENERATE
    p18vt_cast(t_07) <= resize(to_signed(t_07, 32) & '0', 64);
    vt(t_07) <= vt_1(to_integer(resize(p18vt_cast(t_07), 31)));
  END GENERATE vt_gen;


  p20vt_output : PROCESS (tmp_1, vt)
  BEGIN
    vt_13 <= vt;
    vt_13(0) <= tmp_1;
  END PROCESS p20vt_output;


  vt_14 <= vt_13(0);

  vt_15 <= vt_14 + vt_13(1);

  filtered_signal_1 <= resize(vt_15(15 DOWNTO 2), 16);

  y <= resize(esig(15 DOWNTO 2), 16);

  filtered_signal <= filtered_signal_1;

END rtl;

