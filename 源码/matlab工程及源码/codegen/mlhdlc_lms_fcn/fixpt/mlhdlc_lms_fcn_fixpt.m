%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                          %
%          Generated by MATLAB 9.12 and Fixed-Point Designer 7.4           %
%                                                                          %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MATLAB Design: Adaptive Noise Canceler algorithm using Least Mean Square 
% (LMS) filter implemented in MATLAB
%
% Key Design pattern covered in this example: 
% (1) Use of function calls
% (2) Function inlining vs instantiation knobs available in the coder
% (3) Use of system objects in the testbench to stream test vectors into the design
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#codegen
function [filtered_signal, y] = mlhdlc_lms_fcn_fixpt(input, ...
                                        desired)
% 'input'  : The signal from Exterior Mic which records the ambient noise.
% 'desired': The signal from Pilot's Mic which includes 
%            original music signal and the noise signal
% 'err_sig': The difference between the 'desired' and the filtered 'input'
%           It represents the estimated music signal (output of this block)
% 
% The LMS filter is trying to retrieve the original music signal('err_sig') 
% from Pilot's Mic by filtering the Exterior Mic's signal and using it to 
% cancel the noise in Pilot's Mic. The coefficients/weights of the filter 
% are updated(adapted) in real-time based on 'input' and 'err_sig'.

% register filter coefficients
fm = get_fimath();

persistent filter_coeff;
if isempty(filter_coeff)
    filter_coeff = fi(zeros(1, 40), 1, 16, 14, fm);
end

% Variable Filter: Call 'tapped_delay_fcn' function on path to create 
% 40-step tapped delay
delayed_signal = fi(mtapped_delay_fcn(input), 1, 15, 0, fm);

% Apply filter coefficients 
weight_applied = fi(delayed_signal .* filter_coeff, 1, 16, 1, fm);

% Call treesum function on matlab path to sum up the results
filtered_signal = fi(mtreesum_fcn(weight_applied), 1, 16, 0, fm);

% Output estimated Original Signal
td = fi(desired, 1, 15, 0, fm);
tf = fi(filtered_signal, 1, 16, 2, fm);
esig = fi(td - tf, 1, 16, 2, fm);
y = fi(esig, 1, 16, 0, fm);

% Update Weights: Call 'update_weight_fcn' function on MATLAB path to 
% calculate the new weights
updated_weight = fi(update_weight_fcn( esig, delayed_signal, ...
                                   filter_coeff), 1, 16, 14, fm);

% update filter coefficients register
filter_coeff(:) = updated_weight;
end

function tap_delay = mtapped_delay_fcn(input)
% The Tapped Delay function delays its input by the specified number 
% of sample periods, and outputs all the delayed versions in a vector
% form. The output includes current input

% NOTE: To instruct MATLAB Coder to compile an external function, 
% add the following compilation directive or pragma to the function code
%#codegen

fm = get_fimath();

persistent u_d;
if isempty(u_d)
    u_d = fi(zeros(1,40), 1, 15, 0, fm);
end


u_d(:) = [fi(u_d(2:40), 1, 15, 0, fm), input];

tap_delay = fi(u_d, 1, 15, 0, fm);
end

function y = mtreesum_fcn(u)
%Implement the 'sum' function without a for-loop
%  y = sum(u);

%  The loop based implementation of 'sum' function is not ideal for 
%  HDL generation and results in a longer critical path. 
%  A tree is more efficient as it results in
%  delay of log2(N) instead of a delay of N delay

%  This implementation shows how to explicitly implement the vector sum in 
%  a tree shape to enable hardware optimizations.

%  The ideal way to code this generically for any length of 'u' is to use 
%  recursion but it is not currently supported by MATLAB Coder


% NOTE: To instruct MATLAB Coder to compile an external function, 
% add the following compilation directive or pragma to the function code
%#codegen

% This implementation is hardwired for a 40tap filter.

fm = get_fimath();

level1 = fi(vsum_s1(u), 1, 16, 1, fm);
level2 = fi(vsum_s2(level1), 1, 16, 1, fm);
level3 = fi(vsum_s3(level2), 1, 16, 2, fm);
level4 = fi(vsum_s4(level3), 1, 16, 2, fm);
level5 = fi(vsum_s5(level4), 1, 16, 2, fm);
level6 = fi(vsum_s6(level5), 1, 16, 2, fm);
y = fi(level6, 1, 16, 2, fm);
end

function weights = update_weight_fcn(err_sig, ... 
            delayed_signal, filter_coeff)
% This function updates the adaptive filter weights based on LMS algorithm

%   Copyright 2007-2015 The MathWorks, Inc.

% NOTE: To instruct MATLAB Coder to compile an external function, 
% add the following compilation directive or pragma to the function code
%#codegen

fm = get_fimath();

step_sig = fi(fi(0.000000001, 0, 16, 45, fm) .* err_sig, 1, 16, 32, fm);
correction_factor = fi(delayed_signal .* step_sig, 1, 16, 19, fm);
updated_weight = fi(correction_factor + filter_coeff, 1, 16, 14, fm);

  
    weights = fi(updated_weight, 1, 16, 14, fm);
end

function output = vsum_s1(input)

fm = get_fimath();

coder.inline('always');

vt = fi(input(1:2:end), 1, 16, 1, fm);
    
for i = int32(1:numel(input)/2)
    k = fi(int32(i*fi(2, 0, 2, 0, fm)), 0, 6, 0, fm);
    vt(i) = vt(i) + input(k);
end

output = fi(vt, 1, 16, 1, fm);
end

function output = vsum_s2(input)

fm = get_fimath();

coder.inline('always');

vt = fi(input(1:2:end), 1, 16, 1, fm);
    
for i = int32(1:numel(input)/2)
    k = fi(int32(i*fi(2, 0, 2, 0, fm)), 0, 5, 0, fm);
    vt(i) = vt(i) + input(k);
end

output = fi(vt, 1, 16, 1, fm);
end

function output = vsum_s3(input)

fm = get_fimath();

coder.inline('always');

vt = fi(input(1:2:end), 1, 16, 2, fm);
    
for i = int32(1:numel(input)/2)
    k = fi(int32(i*fi(2, 0, 2, 0, fm)), 0, 4, 0, fm);
    vt(i) = vt(i) + input(k);
end

output = fi(vt, 1, 16, 2, fm);
end

function output = vsum_s4(input)

fm = get_fimath();

coder.inline('always');

vt = fi(input(1:2:end), 1, 16, 2, fm);
    
for i = int32(1:numel(input)/2)
    k = fi(int32(i*fi(2, 0, 2, 0, fm)), 0, 3, 0, fm);
    vt(i) = vt(i) + input(k);
end

output = fi(vt, 1, 16, 2, fm);
end

function output = vsum_s5(input)

fm = get_fimath();

coder.inline('always');

vt = fi(input(1:2:end), 1, 16, 2, fm);
    
for i = int32(1:numel(input)/2)
    k = fi(int32(i*fi(2, 0, 2, 0, fm)), 0, 2, 0, fm);
    vt(i) = vt(i) + input(k);
end

output = fi(vt, 1, 16, 2, fm);
end

function output = vsum_s6(input)

fm = get_fimath();

coder.inline('always');

vt = fi(input(1:2:end), 1, 16, 2, fm);
    
for i = int32(1:numel(input)/2)
    k = fi(int32(i*fi(2, 0, 2, 0, fm)), 0, 2, 0, fm);
    vt(i) = vt(i) + input(k);
end

output = fi(vt, 1, 16, 2, fm);
end


function fm = get_fimath()
	fm = fimath('RoundingMethod', 'Floor',...
	     'OverflowAction', 'Wrap',...
	     'ProductMode','FullPrecision',...
	     'SumMode','FullPrecision');
end
